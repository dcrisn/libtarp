#ifndef TARP_BST_H
#define TARP_BST_H

#ifdef __cplusplus
extern "C" {
#endif


#include <stdio.h>
#include <stdlib.h>

#include <tarp/dllist.h>
#include <tarp/staq.h>
#include <tarp/common.h>
#include <tarp/log.h>


/*
 * A BST must be associated with a comparator function at creation time.
 * The comparator gets called with two node values a and b.
 * They are void pointers so the comparator should know how to properly
 * cast them. The return value indicates the (in)equality of a and b in the
 * mold of (3)strcmp (see the comparatorResult enumeration below).
 *    < 0 (a<b)
 *    > 0 (a>b)
 *    0(a==b)
 */
typedef int (*comparator)(const void *a, const void *b);

enum comparatorResult    {LT = -1, EQ = 0, GT = 1};

/*
 * A function that when called with a non-NULL void pointer to some user data
 * (the container of a (potentially augmented) bstnode) returns a non-NULL
 * succint string representation of it. The string should be
 * dynamically allocated and it will be freed internally by the API. */
typedef const char *(*printer)(const void *node);

/*
 * Generic basic binary search tree node;
 *
 * NOTE on embedding this struct as the first member of another struct as  a
 * form of inheritance:
 *  - this *could* be embedded inside a more specific BST type e.g. avlnode,
 *  rbtnode, splaytreenode etc. If so, it must be declared as the *first member*
 *  in that respective structure so that casts to and from that structure can be
 * safely done (not this is *not* undefined behavior. The C standard guarantees
 * there is no padding before the first element of a struct and the pointer
 * to a struct can be cast to a pointer to its first element and back. Don't
 * do it in C++ though, of course). Strict aliasing is also not a concern here.
 * With this being said, I suggest not doing this simply because the code
 * ends up littered with casts. Use the approach suggested next instead.
 *
 * NOTE on autogenerating bst-generic code
 *  - instead of the possible approach touched on above, bstnode augmentations
 *  such as avlnode's should use the bstnode and bsttree as a blueprint in that
 *  they should use the same names for the common fields (left, right etc).
 *  The code that is meant to be bst-generic should then also be autogenerated
 *  as shown below for the trace_path_to_node macro.
 */
struct bstnode {
    struct bstnode *left;
    struct bstnode *right;
#ifndef MAGIC_CONTAINERS
    void *container;
#endif
};

/*
 * The key and value pair stored in nodes is bundled together inside
 * the container and is transparent to the the BST itself;
 * the user-supplied comparator guides all searches, lookups, replacements,
 * and insertions. */
struct bst{
    struct bstnode *root;
    comparator cmp;
    size_t count;
};

 /* defined in bst.c */
struct bst_waypoint;
struct bstnode_ptr;

#define childless(node)         (!(node)->left && !(node)->right)
#define right_child_only(node)  ((node)->right && !(node)->left)
#define left_child_only(node)   ((node)->left  && !(node)->right)
#define both_children(node)     ((node)->left  && (node)->right)

/*
 * This is used for tracing a path from a given node (typically root)
 * to a destination node. See 'trace_path_to_node' FMI.
 *
 * - ptr is a non-NULL pointer to a bst node that represents a waypoint from
 *   source to destination (both inclusive).
 * - dir is the direction to go from this waypoint to get to the next one.
 *   Possible values are -1 (LEFT), 0 (EQUAL, this waypoint *is* the
 *   destination) or 1 (RIGHT).
 */
enum pathTraceDirection  {LEFT = -1, EQUAL = 0, RIGHT = 1};
struct staq_node;

#define BST_NODE_INITIALIZER(container) \
    (struct bstnode){ \
        .left=NULL, \
        .right=NULL, \
        .container = (container) ? container : NULL \
}

/* Macro/function initializer for static BSTs; they do the same thing.
 * cmpf is non-NULL pointer to comparator function (see above). */
#define BST_INITIALIZER(cmpf)     \
    (struct bst){                 \
        .count = 0,               \
        .root = NULL,             \
        .cmp = cmpf               \
    }

void Bst_init(struct bst *tree, comparator cmpf);
size_t Bst_count(const struct bst *tree);
bool Bst_empty(const struct bst *tree);
struct bstnode *Bst_find_node(const struct bst *tree, const struct bstnode *key);
struct bstnode *Bst_find_inorder_sucessor(const struct bstnode *node);
void Bst_print(struct bst *tree, bool graphed, printer pf);

/*
 * Return the height at the given bst node.
 * If NULL, the height is -1. If not NULL but a leaf (childess), the height
 * is 0. Else it is the height of the higher child +1. */
int Bst_find_node_height(const struct bstnode *node);

/*
 * Returns a stack of struct bst_waypoint's.
 * See the comments in tarp/bst.h fmi.
 *
 * --> tree
 * A non-NULL Bst handle to trace the path in.
 *
 * --> path
 * A non-NULL pointer to a staq. This is first going to be (re)initialized,
 * then populated with bst_waypoint's.
 *
 * --> src
 * NULL, or otherwise a a struct bstnode pointer to a node that exists in the
 * tree. This will be the first waypoint pushed onto the stack and where the
 * path tracing starts from. If NULL, the root of the tree will be implicitly
 * used.
 *
 * --> dst
 * A non-NULL pointer to a bstnode where where the path tracing is to stop.
 * The node is fed to the tree comparator to guide the search.
 * If the node is found on the path from src, then it will be the last item
 * pushed onto the stack and the .dir field of the corresponding waypoint
 * will be set to EQUAL so as to indicate this *is* the destination.
 * If the node is not found on the path from src and the end of the tree
 * (a NULL leaf) is reached, then the path tracing stops regardless.
 */
void Bst_trace_path_to_node(
        const struct bst *tree,
        struct staq *path,
        const struct bstnode *src,
        const struct bstnode *dst);

/*
 * Perform a left rotation to move child b above parent a.
 *
 * Given:
 *   A
 *  / \
 * G   B
 *    / \
 *   C   D
 *
 * the left rotation will produce:
 *     B
 *    / \
 *   A   D
 *  / \
 * G   C
 */
struct bstnode *Bst_rotate_left(
        struct bstnode *a,
        struct bstnode *b);

/*
 * Perform a right rotation to move child b above parent a.
 * Given:
 *     A
 *    / \
 *   B   G
 *  / \
 * C   D
 *
 * the right rotation will produce:
 *     B
 *    / \
 *   C   A
 *      / \
 *     D   G
 */
struct bstnode *rotate_right(
        struct bstnode *a,
        struct bstnode *b);


/***********************************************************************
 * ================ Code autogeneration ===============================|
 ********************************************************************
 *
 * A collection of basic code-generating macros to simplify writing
 * the boilerplate for bst trees e.g. AVL, Red-black etc that have
 * much shared (helper) logic.
 *
 * For all the functions below, the parameters where present are as
 * follows:
 *
 *   - SHORTNAME : a prefix to prepend to the function name e.g.,
 *   Avl, Bst etc ==> Avl_get_nodes_at_level, Avl_count etc.
 *
 *   - TREE_TYPE : the type of the tree handle structure e.g.
 *   struct bst, struct avltree etc.
 *
 *   - NODE_TYPE : the type of the tree node structure e.g.
 *   struct avlnode, struct bstnode etc.
 *
 *   - vistype : either <private> or <public>. If vistype=private
 *   the static qualifier will be put before the function. Otherwise
 *   if vistype=public, no qualifier is added.
 *
 * Other parameters are specific to the function or struct in
 * question e.g. WAYPOINT_TYPE is meant to have been generated
 * previously via define_bst_waypoint_structure.
 *
 ********************************************************************/

#define define_bst_waypoint_structure(SHORTNAME, TYPE)          \
    struct SHORTNAME##_waypoint {                               \
        staq_node link;                                         \
        TYPE *ptr;                                              \
        enum pathTraceDirection dir;                            \
    };

#define define_bstnode_ptr_wrapper_structure(SHORTNAME, TYPE)   \
    struct SHORTNAME##_ptr {                                    \
        staq_node link;                                         \
        TYPE *p;                                                \
    };

#define define_bst_count_getter(vistype, SHORTNAME, TREE_TYPE)      \
    vis(vistype) size_t SHORTNAME##_count(const TREE_TYPE *tree){   \
        assert(tree);                                               \
        return tree->count;                                         \
    }

#define define_bst_empty_predicate(vistype, SHORTNAME, TREE_TYPE)  \
    vis(vistype) bool SHORTNAME##_empty(const TREE_TYPE *tree){    \
        assert(tree);                                              \
        return (tree->count == 0);                                 \
    }

#define define_bst_node_finder(vistype, SHORTNAME, TREE_TYPE, NODE_TYPE) \
    vis(vistype) NODE_TYPE *SHORTNAME##_find_node(                       \
            const TREE_TYPE *tree,                                       \
            const NODE_TYPE *key)                                        \
{                                                                        \
    assert(tree);                                                        \
    assert(key);                                                         \
    if (tree->count == 0) return NULL;                                   \
                                                                         \
    NODE_TYPE *node = tree->root;                                        \
    comparator cmp = tree->cmp;                                          \
    assert(node);                                                        \
    while (node){                                                        \
        switch(cmp(container(key, void), container(node, void))){        \
        case LT: node = node->left; break;                               \
        case EQ: return node;                                            \
        case GT: node = node->right; break;                              \
        default: assert(false);                                          \
        }                                                                \
    }                                                                    \
    return NULL;                                                         \
}

#define define_bst_inorder_successor_finder(vistype, SHORTNAME, NODE_TYPE)  \
    vis(vistype) NODE_TYPE *SHORTNAME##_find_inorder_successor(      \
            const NODE_TYPE *node)                                          \
{                                                                           \
        assert(node);                                                       \
        node = node->right;                                                 \
        while (node && node->left){                                         \
            node = node->left;                                              \
        }                                                                   \
        return (NODE_TYPE*)node;                                            \
}

#define define_bst_path_tracer(                                         \
        vistype, SHORTNAME, TREE_TYPE, NODE_TYPE, WAYPOINT_TYPE)        \
    vis(vistype) void SHORTNAME##_trace_path_to_node(                   \
        const TREE_TYPE *tree,                                          \
        struct staq *path,                                              \
        const NODE_TYPE *src,                                           \
        const NODE_TYPE *dst)                                           \
{                                                                       \
    assert(tree);                                                       \
    assert(path);                                                       \
    assert(dst);                                                        \
    NODE_TYPE *node = src ? (NODE_TYPE*)src : tree->root;               \
                                                                        \
    *path = STAQ_INITIALIZER;                                           \
    WAYPOINT_TYPE *p;                                                   \
                                                                        \
    if (tree->count == 0) return;                                       \
                                                                        \
    comparator cmp = tree->cmp;                                         \
    assert(node);                                                       \
    assert(cmp);                                                        \
    debug("reached here");                                              \
                                                                        \
    size_t waypointsz = sizeof(WAYPOINT_TYPE);                          \
                                                                        \
    while (node){                                                       \
        switch(cmp(container(dst, void), container(node, void))){       \
        case LT:                                                        \
            p = salloc(waypointsz, NULL);                               \
            p->ptr = node; p->dir = LEFT;                               \
            Staq_push(path, p, link);                                   \
            node = node->left;                                          \
            break;                                                      \
        case GT:                                                        \
            p = salloc(waypointsz, NULL);                               \
            p->ptr = node; p->dir = RIGHT;                              \
            Staq_push(path, p, link);                                   \
            node = node->right;                                         \
            break;                                                      \
        case EQ:                                                        \
            p = salloc(waypointsz, NULL);                               \
            p->ptr = node; p->dir = EQUAL;                              \
            Staq_push(path, p, link);                                   \
            return;                                                     \
        default: assert(false);                                         \
        }                                                               \
    }                                                                   \
}

/* NOTE: always frees the container as well! */
#define define_bst_cut_down(vistype, SHORTNAME, NODE_TYPE)    \
    vis(vistype) void SHORTNAME##_cut_down(NODE_TYPE *root){  \
        if (!root) return;                                    \
        SHORTNAME##_cut_down(root->left);                     \
        SHORTNAME##_cut_down(root->right);                    \
        free(root->container);                                \
}


#define define_bst_rotate_left(vistype, SHORTNAME, NODE_TYPE)          \
    vis(vistype) NODE_TYPE *SHORTNAME##_rotate_left(                   \
            NODE_TYPE *a, NODE_TYPE *b)                                \
{                                                                      \
    a->right = b->left;                                                \
    b->left = a;                                                       \
    return b;                                                          \
}

#define define_bst_rotate_right(vistype, SHORTNAME, NODE_TYPE)         \
    vis(vistype) NODE_TYPE *SHORTNAME##_rotate_right(                  \
            NODE_TYPE *a, NODE_TYPE *b)                                \
{                                                                      \
    a->left = b->right;                                                \
    b->right = a;                                                      \
    return b;                                                          \
}

/*
 * Thin wrapper for storing strings in a dllist */
struct string_qlink {
    dlnode link;
    const char *s;
};

/*
 * Helper function to print BACKLOG -- used
 * by BST_graphed_print__() function.
 */
static inline void println__(struct dllist *list){
    assert(list);
    struct string_qlink *sql;
    Dll_foreach(list, sql, struct string_qlink){
        printf("%s", sql->s);
    }
}

/*
 * Pretty print of a tree to the console. For example:
 *
 *             .---- (4) bwdad
 *           .---- (3) bde
 *       .---- (2) bd
 *       :   `---- (3) bca
 *   <[(1)] bc
 *       :   .---- (3) bbb
 *       `---- (2) bb
 *           :   .---- (4) bar
 *           `---- (3) ba
 *
 * Parenthesized are the levels. Root is at level one.
 * The function is meant as a visual debugging tool. It immediately gives
 * you an idea of how balanced, or, conversely, degenerate, a tree is,
 * for example.
 *
 * --> parent
 *     The parent of the current node. Calling code should pass this as NULL
 *     since the first node is root, which doesn't have a parent. Then the
 *     function will call itself recursively starting from root.
 *
 * --> backlog
 *     A linked list/ queue of strings (dllist), that the function must print
 *     when reaching a particular node *before* printing the string
 *     representation of the node itself. See below fmi.
 *
 * --> level
 *    The current level the current node is at. Root is at level 1. Calling code
 *    should therefore pass 1 for this parameter. This will then get incremented
 *    recursively.
 *
 * --> node
 *     The current node. Calling code should pass the root of a tree object for
 *     this parameter.
 */
#define define_bst_graphic_dump(vistype, SHORTNAME, NODE_TYPE)               \
    vis(vistype) void SHORTNAME##_dump_tree_graph(                           \
            NODE_TYPE *node,                                                 \
            printer node2string,                                             \
            NODE_TYPE *parent,                                               \
            struct dllist *backlog,                                          \
            size_t level)                                                    \
{                                                                            \
    debug("called");                                                         \
    if (!node) return;                                                       \
                                                                             \
    char *level_trace = ":   ";                                              \
    char *padding     = "    ";                                              \
    const size_t sz = 30;                                                    \
    char str[sz];  memset(str, 0, ARRLEN(str));                              \
    char *right_fill = NULL;                                                 \
    char *left_fill = NULL;                                                  \
    level = level > 0 ? level : 1;                                           \
    struct string_qlink sql; /* static, kept in scope by recursion frames */ \
                                                                             \
    void *udata = container(node, void); /* node2string must interpret it */ \
                                                                             \
     /* the decision of what string to and what to pass to the children */   \
     /* is made at each node and it depends on whether the current node */   \
     /* does NOT have a parent(is root), or is a left or right child ... */  \
    if (!parent){                                                            \
        /* root */                                                           \
        const char *s = node2string(udata);                                  \
        snprintf(str, sz-1, "<[(%zu)] %-6s\n", level, s);                    \
        free((void*)s);                                                      \
                                                                             \
        right_fill = left_fill = padding;                                    \
        /* info("root; fill right and left: '%s'", right_fill); */           \
    }                                                                        \
    else if (node == parent->right){                                         \
        const char *s = node2string(udata);                                  \
        snprintf(str, sz-1, ".---- (%zu) %-6s\n", level, s);                 \
        free((void*)s);                                                      \
                                                                             \
        left_fill = level_trace;                                             \
        right_fill = padding;                                                \
    }                                                                        \
    else if (node == parent->left){                                          \
        const char *s = node2string(udata);                                  \
        snprintf(str, sz-1, "`---- (%zu) %-6s\n", level, s);                 \
        free((void*)s);                                                      \
                                                                             \
        right_fill = level_trace;                                            \
        left_fill = padding;                                                 \
    }                                                                        \
                                                                             \
    /* print right children first (recursively), then current node, then */  \
    /* left child; since the print must be line by line, hence rightmost */  \
    /* to leftmost                                                       */  \
                                                                             \
    /* ... but the decision of whether the string constructed by the  */     \
    /* current node is passed on to the child so that they can append */     \
    /* their own string part depends on whether the node HAS a right  */     \
    /* and/or left child, respectively                                */     \
    if (node->right){                                                        \
        sql.s = right_fill;                                                  \
        Dll_pushback(backlog, &sql, link);                                   \
        SHORTNAME##_dump_tree_graph(                                         \
                node->right, node2string, node, backlog, level+1);           \
        Dll_popback(backlog, struct string_qlink); /* pop child filler */    \
    }                                                                        \
                                                                             \
    /* root does not have a backlog */                                       \
    if (parent){                                                             \
        println__(backlog);                                                  \
    }                                                                        \
    printf("%s", str);                                                       \
                                                                             \
    if (node->left){                                                         \
        sql.s = left_fill;                                                   \
        Dll_pushback(backlog, &sql, link);                                   \
        SHORTNAME##_dump_tree_graph(                                         \
                node->left, node2string, node, backlog, level+1);            \
        Dll_popback(backlog, struct string_qlink); /* pop child filler  */   \
    }                                                                        \
                                                                             \
    return;                                                                  \
}

#define define_bst_height_getter(vistype, SHORTNAME, NODE_TYPE)             \
    vis(vistype) int SHORTNAME##_find_node_height(const NODE_TYPE *node){   \
        if(!node) return -1;                                                \
        return 1 + MAX(                                                     \
                SHORTNAME##_find_node_height(node->left),                   \
                SHORTNAME##_find_node_height(node->right)                   \
                );                                                          \
    }

#define define_get_nodes_at_level(                                           \
        vistype, SHORTNAME, NODE_TYPE, PTR_WRAPPER_TYPE)                     \
    vis(vistype) void SHORTNAME##_get_nodes_at_level(                        \
            const NODE_TYPE *root,                                           \
            size_t level,                                                    \
            struct staq *list                                                \
            )                                                                \
{                                                                            \
    if (!root) return;                                                       \
    assert(list);                                                            \
                                                                             \
    /* reached desired level */                                              \
    if (level == 1){                                                         \
        PTR_WRAPPER_TYPE *p = salloc(sizeof(NODE_TYPE), NULL);               \
        p->p = (NODE_TYPE *)root;                                            \
        Staq_enq(list, p, link);                                             \
        return;                                                              \
    }                                                                        \
                                                                             \
    SHORTNAME##_get_nodes_at_level(root->left, level-1, list);               \
    SHORTNAME##_get_nodes_at_level(root->right, level-1, list);              \
}



#ifdef __cplusplus
} /* extern "C */
#endif



#endif
