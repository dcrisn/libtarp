#ifndef TARP_BST_H
#define TARP_BST_H

#ifdef __cplusplus
extern "C" {
#endif


#include <stdio.h>
#include <stdlib.h>
#include <tarp/common.h>

struct bst;
struct bstnode;

/*
 * A BST must be associated with a comparator function at creation time.
 * see common.h
 */

/*
 * A function that when called with a non-NULL void pointer to some user data
 * (the container of a (potentially augmented) bstnode) returns a non-NULL
 * succint string representation of it. The string should be
 * dynamically allocated and it will be freed internally by the API. */
typedef const char *(*bstnode_printer)(const struct bstnode *node);

/*
 * A function that when called with a non-NULL bstnode pointer, it should
 * return a void pointer to its enclosing container as appropriate.
 * The return value *must* be obtained from get_container() */
typedef void (*bstnode_destructor)(struct bstnode *node);

/*
 * Generic basic binary search tree node;
 *
 * NOTE on embedding this struct as the first member of another struct as  a
 * form of inheritance:
 *  - this *could* be embedded inside a more specific BST type e.g. avlnode,
 *  rbtnode, splaytreenode etc. If so, it must be declared as the *first member*
 *  in that respective structure so that casts to and from that structure can be
 * safely done (not this is *not* undefined behavior. The C standard guarantees
 * there is no padding before the first element of a struct and the pointer
 * to a struct can be cast to a pointer to its first element and back. Don't
 * do it in C++ though, of course). Strict aliasing is also not a concern here.
 * With this being said, I suggest not doing this simply because the code
 * ends up littered with casts. Use the approach suggested next instead.
 *
 * NOTE on autogenerating bst-generic code
 *  - instead of the possible approach touched on above, bstnode augmentations
 *  such as avlnode's should use the bstnode and bsttree as a blueprint in that
 *  they should use the same names for the common fields (left, right etc).
 *  The code that is meant to be bst-generic should then also be autogenerated
 *  as shown below for the trace_path_to_node macro.
 */
struct bstnode {
    struct bstnode *left;
    struct bstnode *right;
};

typedef enum comparatorResult (*bst_comparator)\
    (const struct bstnode *a, const struct bstnode *b);

/*
 * The key and value pair stored in nodes is bundled together inside
 * the container and is transparent to the the BST itself;
 * the user-supplied comparator guides all searches, lookups, replacements,
 * and insertions. */
struct bst{
    struct bstnode *root;
    bst_comparator cmp;
    size_t count;
    bstnode_destructor dtor;
};

#include "impl/bst_impl.h"

 /* defined in bst.c */
struct bst_waypoint;
struct bstnode_ptr;

#define childless(node)         (!(node)->left && !(node)->right)
#define right_child_only(node)  ((node)->right && !(node)->left)
#define left_child_only(node)   ((node)->left  && !(node)->right)
#define both_children(node)     ((node)->left  && (node)->right)

/*
 * This is used for tracing a path from a given node (typically root)
 * to a destination node. See 'trace_path_to_node' FMI.
 *
 * - ptr is a non-NULL pointer to a bst node that represents a waypoint from
 *   source to destination (both inclusive).
 * - dir is the direction to go from this waypoint to get to the next one.
 *   Possible values are -1 (LEFT), 0 (EQUAL, this waypoint *is* the
 *   destination) or 1 (RIGHT).
 */
enum pathTraceDirection  {LEFT = -1, EQUAL = 0, RIGHT = 1};
struct staqnode;

/* Macro/function initializer for static BSTs; they do the same thing.
 * cmpf is non-NULL pointer to comparator function (see above). */
#define BST_INITIALIZER(cmpf, dtor)   BST_INITIALIZER__(cmpf, dtor)
void Bst_init(struct bst *tree, bst_comparator cmpf, bstnode_destructor dtor);

size_t Bst_count(const struct bst *tree);
bool Bst_empty(const struct bst *tree);
struct bstnode *Bst_find_node(const struct bst *tree, const struct bstnode *key);
struct bstnode *Bst_find_inorder_sucessor(const struct bstnode *node);

/*
 * Return the height at the given bst node.
 * If NULL, the height is -1. If not NULL but a leaf (childess), the height
 * is 0. Else it is the height of the higher child +1. */
int Bst_find_node_height(const struct bstnode *node);

/*
 * Returns a stack of struct bst_waypoint's.
 * See the comments in tarp/bst.h fmi.
 *
 * --> tree
 * A non-NULL Bst handle to trace the path in.
 *
 * --> path
 * A non-NULL pointer to a staq. This is first going to be (re)initialized,
 * then populated with bst_waypoint's.
 *
 * --> src
 * NULL, or otherwise a a struct bstnode pointer to a node that exists in the
 * tree. This will be the first waypoint pushed onto the stack and where the
 * path tracing starts from. If NULL, the root of the tree will be implicitly
 * used.
 *
 * --> dst
 * A non-NULL pointer to a bstnode where where the path tracing is to stop.
 * The node is fed to the tree comparator to guide the search.
 * If the node is found on the path from src, then it will be the last item
 * pushed onto the stack and the .dir field of the corresponding waypoint
 * will be set to EQUAL so as to indicate this *is* the destination.
 * If the node is not found on the path from src and the end of the tree
 * (a NULL leaf) is reached, then the path tracing stops regardless.
 */
void Bst_trace_path_to_node(
        const struct bst *tree,
        struct staq *path,
        const struct bstnode *src,
        const struct bstnode *dst);

/*
 * Perform a left rotation to move child b above parent a.
 *
 * Given:
 *   A
 *  / \
 * G   B
 *    / \
 *   C   D
 *
 * the left rotation will produce:
 *     B
 *    / \
 *   A   D
 *  / \
 * G   C
 */
struct bstnode *Bst_rotate_left(
        struct bstnode *a,
        struct bstnode *b);

/*
 * Perform a right rotation to move child b above parent a.
 * Given:
 *     A
 *    / \
 *   B   G
 *  / \
 * C   D
 *
 * the right rotation will produce:
 *     B
 *    / \
 *   C   A
 *      / \
 *     D   G
 */
struct bstnode *rotate_right(
        struct bstnode *a,
        struct bstnode *b);


/***********************************************************************
 * ================ Code autogeneration ===============================|
 ********************************************************************
 *
 * A collection of basic code-generating macros to simplify writing
 * the boilerplate for bst trees e.g. AVL, Red-black etc that have
 * much shared (helper) logic.
 *
 * For all the functions below, the parameters where present are as
 * follows:
 *
 *   - SHORTNAME : a prefix to prepend to the function name e.g.,
 *   Avl, Bst etc ==> Avl_get_nodes_at_level, Avl_count etc.
 *
 *   - TREE_TYPE : the type of the tree handle structure e.g.
 *   struct bst, struct avltree etc.
 *
 *   - NODE_TYPE : the type of the tree node structure e.g.
 *   struct avlnode, struct bstnode etc.
 *
 *   - vistype : either <private> or <public>. If vistype=private
 *   the static qualifier will be put before the function. Otherwise
 *   if vistype=public, no qualifier is added.
 *
 * Other parameters are specific to the function or struct in
 * question e.g. WAYPOINT_TYPE is meant to have been generated
 * previously via define_bst_waypoint_structure.
 *
 ********************************************************************/

#define define_bst_waypoint_structure(SHORTNAME, TYPE)                 \
    struct SHORTNAME##_waypoint {                                      \
        staqnode link;                                                 \
        TYPE *ptr;                                                     \
        enum pathTraceDirection dir;                                   \
    };

#define define_bstnode_ptr_wrapper_structure(SHORTNAME, TYPE)    \
    struct SHORTNAME##_ptr {                                     \
        staqnode link;                                           \
        TYPE *p;                                                 \
    };

#define define_bst_count_getter(vistype, SHORTNAME, TREE_TYPE)      \
    define_bst_count_getter_(vistype, SHORTNAME, TREE_TYPE)

#define define_bst_empty_predicate(vistype, SHORTNAME, TREE_TYPE)  \
    define_bst_empty_predicate_(vistype, SHORTNAME, TREE_TYPE)

#define define_bst_node_finder(vistype, SHORTNAME, TREE_TYPE, NODE_TYPE) \
    define_bst_node_finder_(vistype, SHORTNAME, TREE_TYPE, NODE_TYPE)

#define define_bst_boolean_lookup(vistype, SHORTNAME, TREE_TYPE, NODE_TYPE) \
    define_bst_boolean_lookup_(vistype, SHORTNAME, TREE_TYPE, NODE_TYPE)

#define define_bst_inorder_successor_finder(vistype, SHORTNAME, NODE_TYPE)  \
    define_bst_inorder_successor_finder_(vistype, SHORTNAME, NODE_TYPE)

#define define_bst_path_tracer(vistype, SHORTNAME, TREE_TYPE, NODE_TYPE, WAYPOINT_TYPE) \
    define_bst_path_tracer_(                                                     \
        vistype, SHORTNAME, TREE_TYPE, NODE_TYPE, WAYPOINT_TYPE)

/* NOTE: always frees the container as well! */
#define define_bst_cut_down(vistype, SHORTNAME, TREE_TYPE, NODE_TYPE)    \
    define_bst_cut_down_(vistype, SHORTNAME, TREE_TYPE, NODE_TYPE)

#define define_bst_rotate_left(vistype, SHORTNAME, NODE_TYPE)          \
    define_bst_rotate_left_(vistype, SHORTNAME, NODE_TYPE)

#define define_bst_rotate_right(vistype, SHORTNAME, NODE_TYPE)         \
    define_bst_rotate_right_(vistype, SHORTNAME, NODE_TYPE)

#define define_bst_graphic_dump(vistype, SHORTNAME, TREE_TYPE, NODE_TYPE, PRINTER_TYPE)    \
    define_bst_graphic_dump_(vistype, SHORTNAME, TREE_TYPE, NODE_TYPE, PRINTER_TYPE)

#define define_bst_height_getter(vistype, SHORTNAME, NODE_TYPE)             \
    define_bst_height_getter_(vistype, SHORTNAME, NODE_TYPE)

/*
 * level is taken here to mean 'depth' and it is 1-based. Root is at
 * level one. The tree has as many levels as it has height/depth;
 * If q is not NULL, each node is enqueued in FIFO fashion, from the left
 * of the tree to the right. If count is not NULL, the count of the number
 * of nodes at the specified level is stored in it. It must have been
 * initialized to 0 before calling this function.
 *
 * NOTE this function is recursive so it's not recommended for non-balanced
 * BST if they can degenerate and cause the recursion depth to be exceeded.
 */
#define define_get_nodes_at_level(vistype, SHORTNAME, NODE_TYPE, PTR_WRAPPER_TYPE) \
    define_get_nodes_at_level_(vistype, SHORTNAME, NODE_TYPE, PTR_WRAPPER_TYPE)

#define define_bst_max_getter(vistype, SHORTNAME, TREE_TYPE, NODE_TYPE)  \
    define_bst_max_getter_(vistype, SHORTNAME, TREE_TYPE, NODE_TYPE)

#define define_bst_min_getter(vistype, SHORTNAME, TREE_TYPE, NODE_TYPE)    \
    define_bst_min_getter_(vistype, SHORTNAME, TREE_TYPE, NODE_TYPE)



#ifdef __cplusplus
} /* extern "C */
#endif



#endif
