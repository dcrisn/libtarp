#ifndef TARP_BITS_H
#define TARP_BITS_H

#ifdef __cplusplus
extern "C" {
#endif


#include <stddef.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>


#define BITS_IN_BYTE 8U

#define WIDTH_U64 64U
#define WIDTH_U32 32U
#define WIDTH_U16 16U
#define WIDTH_U8  8U

#define ON_BIT  1U
#define OFF_BIT 0U


/*
 * left rotational bit shift;
 * NOTE: it's UB for n to be >= w
 */
#define lrot(x, n, w) (((x) << (n)) | ((x) >> (w-(n))))
#define lrotu64(x, n) lrot(x, n, WIDTH_U64)
#define lrotu32(x, n) lrot(x, n, WIDTH_U32)
#define lrotu16(x, n) lrot(x, n, WIDTH_U16)

/*
 * right rotational bit shift;
 * NOTE: it's UB for n to be >= w
 */
#define rrot(x, n, w) (((x) >> (n)) | ((x) << (w-(n))))
#define rrotu64(x, n) rrot(x, n, WIDTH_U64)
#define rrotu32(x, n) rrot(x, n, WIDTH_U32)
#define rrotu16(x, n) rrot(x, n, WIDTH_U16)

/*
 * todo compare the assembly generated by this macro to the assemly generated 
 * by a more usual implementation with a loop and a temporary variable;
 * also time them and get them to reverse a couple thousnd uint64ts */
#define revu64(i) \
   ( \
     ((uint64_t)i & (uint64_t) 0x00000000000000ff)   << 56 |     \
     ((uint64_t)i & (uint64_t) 0x000000000000ff00)   << 40 |     \
     ((uint64_t)i & (uint64_t) 0x0000000000ff0000)   << 24 |     \
     ((uint64_t)i & (uint64_t) 0x00000000ff000000)   << 8  |     \
     ((uint64_t)i & ((uint64_t)0x000000ff00000000))  >> 8  |     \
     ((uint64_t)i & (uint64_t) 0x0000ff000000ff00)   >> 24 |     \
     ((uint64_t)i & (uint64_t) 0x00ff000000000000)   >> 40 |     \
     ((uint64_t)i & ((uint64_t)0xff00000000000000))  >> 56       \
   )

#define revu32(i) \
   ( \
     ((uint32_t)i & (uint32_t) 0x000000ff)   << 24 |    \
     ((uint32_t)i & ((uint32_t)0xff000000))  >> 24 |    \
     ((uint32_t)i & (uint32_t) 0x0000ff00)   << 8  |    \
     ((uint32_t)i & ((uint32_t)0x00ff0000))  >> 8       \
   )

#define revu16(i) \
    ( \
      ((uint16_t)i & (uint16_t)0xff00) >> 8 |    \
      ((uint16_t)i & (uint16_t)0x00ff) << 8      \
    )

/* 
 * Reverse *bits* in a byte. */
#define revu8(i) \
    (\
     (i & 128) >> 7 | (i & 1) << 7 |     \
     (i & 64)  >> 5 | (i & 2) << 5 |     \
     (i & 32)  >> 3 | (i & 4) << 3 |     \
     (i & 16)  >> 1 | (i & 8) << 1       \
    )

static inline size_t bytes2bits(size_t nbytes){
    return nbytes * BITS_IN_BYTE;
}

/*
 * return number of bytes required to store nbits */
static inline size_t bits2bytes(size_t nbits){
    return (nbits / BITS_IN_BYTE) + (nbits % BITS_IN_BYTE ? 1 : 0);
}

/*
 * Get, set, clear, or toggle the bit (1 or 0) at position pos in num.
 *
 * the rightmost bit is considered to be at position 1, increasing to the left.
 * It is assumed pos is not out of bounds of the width of the 'num' type.
 */
#define get_bit(num, pos) \
    ((num >> (pos-1)) & ON_BIT)

#define set_bit(num, pos) \
    (num | (ON_BIT << (pos-1)))

#define clear_bit(num, pos) \
    (num & ~(ON_BIT << (pos-1)))

#define toggle_bit(num, pos) \
    (num ^ (ON_BIT << (pos-1)))

/*
 * Get, set, clear, or toggle a number of adjacent bits.
 *
 * 'nbits' bits are operated on from pos to the right. See the comment on
 * get_bit for how bit positions are counted. A call such as get_bits(mynum, 4, 2)
 * will therefore get the bits at positions 4 and 3.
 *
 * Note get_bits shifts right at the end such that in the return value the
 * rightmost bit is the rightmost bit *that the user asked to be gotten*. So for
 * example if mynum=11001100, a call such as get_bits(mynum, 4, 2) will return
 * 00000011.
 *
 * To understand the below macros, note the following:
 *  - ~0U gives a mask of all 1s
 *  - we cast this to the same type as num to avoid subtle promotion weirdness.
 *  For example, if num is a uint64_t but our mask is made a uint32_t, then pos
 *  may correctly be specified as e.g. 55, but that's a shift beyond the witdth
 *  of a u32, resulting in undefined behavior. Note if typeof is unimplemented
 *  in the current compiler, just replace it with a cast to uint64_t instead
 *  (widest integer available).
 *  - (~0U << nbits) clears up <nbits> 0 bits on the far right, with all the other
 *  bits being 1. Negating this again therefore gives us <nbits> 1 bits on the
 *  far right with all the other bits being 0. This is our mask that we can
 *  shift to the left to the required position.
 *  - using the mask obtained at the previous step, we can shift it to the
 *  required position to the left. We've already shifted NBITS times, so we only
 *  have pos-nbits times left to shift.
 *  
 *  Preconditions on the inputs
 *  ----------------------------
 *  As implied above, nbits must be <= pos, otherwise the request is nonsensical
 *  and the behavior is undefined. Additionally:
 *   - pos *must* be <= the width of the type of 'num'.
 *   - nbits *must* be > 0.
 */
#define get_bits(num, pos, nbits) \
    ( ( num & ((~ (~((typeof(num))0) << nbits) ) << (pos-nbits))) >> (pos - nbits) )

#define set_bits(num, pos, nbits) \
    ( num | ((~(~((typeof(num))0) << nbits)) << (pos-nbits)))

#define clear_bits(num, pos, nbits) \
    ( num & ~((~(~((typeof(num))0) << nbits)) << (pos-nbits)))

#define toggle_bits(num, pos, nbits) \
    ( num ^ ((~(~((typeof(num))0) << nbits)) << (pos-nbits)))

/*
 * see 2's complement */
static inline bool ispow2(uint64_t x){
    if ((x & (x-1)) == 0) return true;
    return false;
}

/*
 * return the position of the most significant bit, counting from 1.
 */
static inline int posmsb(uint64_t v){
    if (!v) return 0;

    int pos = 0;
    while (v>>=1 && ++pos);
    return pos;
}

/*
 * return an integral value (if you want float, see `man 2 log2`) which is the
 * position of the most significant bit in num, counting from 1. This is
 * equivalent to the truncated value of log2(num).
 */
static inline int lg(uint64_t num){
    return posmsb(num);
}

/*
 * Check if width (in bits) is wide enough to accomodate val.
 * For val to fit in width, width must be >= the position (counting from 1)
 * of the most significant bit in val.
 */
static inline bool wide_enough(int width, uint64_t val){
    return (width >= posmsb(val));
}

/*
 * generate special functions for performing '%'; when the modulus is a power
 * of 2, this can be implemented via a bitwise AND.
 *
 * NOTE:
 *  - type must be wide enough to fit pow_of_2. I.e. 
 *  IOW ensure: log_2(pow_of_2) <= sizeof(type)*8.
 */
#define define_modulo_pow2(type, postfix, pow_of_2) \
    type mod##postfix(type val){ \
        return val & pow_of_2; \
    }
    
/*
 * Return a dynamically allocated string that contains the bits in val, left to
 * right in decreasing order of significance.
 *
 * --> val
 * the value to get the bits of.
 *
 * --> width
 * the number of bits (from least significant to most significant) to show; if
 * this is less than the width of val, the higher-order bits that do not fit are
 * left out. If this is more than the width of val, high order 0 bits are filled
 * in to pad out the output.
 *
 * <-- return
 * a dynamically allocated string that the user must free().
 */
const char *bitstr(uint64_t val, size_t width);

/*
 * For each byte in src, write it to dst formatted as follows:
 *  [prefix][2 digit hex][separator]
 *
 * The separator is only printed between elements. Prefix and separator can be
 * NULL (default is empty strings if so). dst must have enough space to
 * accomodate the format of every byte in src + a NUL terminator. If this is not
 * so, -1 is returned to indicate the error.
 */
int hexstr(
        char dst[],   size_t dstlen,
        uint8_t src[],size_t srclen,
        const char *const delim,
        const char *const prefix);

/*
 * Produce a hex dump of the bytes starting at <start>.
 *
 * --> start
 * First byte (inclusive) to start dumping from.
 *
 * --> len
 * The length in bytes of the memory available to dump.
 *
 * --> width
 * How many bytes to show per line in the output
 *
 * --> print_offsets
 * Whether to print a hex number at the start of each line indicating the offset
 * inside the dump of the first byte on that line. For example '0x000040 |'.
 */
void dump_hex(
    const uint8_t *start,
    uint32_t len,
    uint16_t width,
    bool print_offsets);


#ifdef __cplusplus
} /* extern "C" */
#endif

#endif
