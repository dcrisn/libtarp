#ifndef TARP_BITS_H
#define TARP_BITS_H

#ifdef __cplusplus
extern "C" {
#endif


#include <stddef.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#include <tarp/pedantic.h>


#define BITS_IN_BYTE 8U

#define WIDTH_U64 64U
#define WIDTH_U32 32U
#define WIDTH_U16 16U
#define WIDTH_U8  8U

#define ON_BIT  1U
#define OFF_BIT 0U

#define NULL_BYTE 0x00U
#define FULL_BYTE 0xFFU

#define bit2char(bit) ( (bit==ON_BIT) ? '1' : ((bit==OFF_BIT) ? '0' : '?') )
#define isbit(num) (num == ON_BIT || num == OFF_BIT)

/*
 * left rotational bit shift;
 * NOTE: it's UB for n to be >= w
 */
#define lrot(x, n, w) (((x) << (n)) | ((x) >> (w-(n))))
#define lrotu64(x, n) lrot(x, n, WIDTH_U64)
#define lrotu32(x, n) lrot(x, n, WIDTH_U32)
#define lrotu16(x, n) lrot(x, n, WIDTH_U16)
#define lrotu8(x, n) lrot(x, n, WIDTH_U8)

/*
 * right rotational bit shift;
 * NOTE: it's UB for n to be >= w
 */
#define rrot(x, n, w) (((x) >> (n)) | ((x) << (w-(n))))
#define rrotu64(x, n) rrot(x, n, WIDTH_U64)
#define rrotu32(x, n) rrot(x, n, WIDTH_U32)
#define rrotu16(x, n) rrot(x, n, WIDTH_U16)
#define rrotu8(x, n) rrot(x, n, WIDTH_U8)

/*
 * todo compare the assembly generated by this macro to the assemly generated
 * by a more usual implementation with a loop and a temporary variable;
 * also time them and get them to reverse a couple thousnd uint64ts */
#define revu64(i) \
   ( \
     ((uint64_t)i & (uint64_t) 0x00000000000000ff)   << 56 |     \
     ((uint64_t)i & (uint64_t) 0x000000000000ff00)   << 40 |     \
     ((uint64_t)i & (uint64_t) 0x0000000000ff0000)   << 24 |     \
     ((uint64_t)i & (uint64_t) 0x00000000ff000000)   << 8  |     \
     ((uint64_t)i & ((uint64_t)0x000000ff00000000))  >> 8  |     \
     ((uint64_t)i & (uint64_t) 0x0000ff000000ff00)   >> 24 |     \
     ((uint64_t)i & (uint64_t) 0x00ff000000000000)   >> 40 |     \
     ((uint64_t)i & ((uint64_t)0xff00000000000000))  >> 56       \
   )

#define revu32(i) \
   ( \
     ((uint32_t)i & (uint32_t) 0x000000ff)   << 24 |    \
     ((uint32_t)i & ((uint32_t)0xff000000))  >> 24 |    \
     ((uint32_t)i & (uint32_t) 0x0000ff00)   << 8  |    \
     ((uint32_t)i & ((uint32_t)0x00ff0000))  >> 8       \
   )

#define revu16(i) \
    ( \
      ((uint16_t)i & (uint16_t)0xff00) >> 8 |    \
      ((uint16_t)i & (uint16_t)0x00ff) << 8      \
    )

/*
 * Reverse *bits* in a byte. */
#define revu8(i) \
    (\
     (i & 128) >> 7 | (i & 1) << 7 |     \
     (i & 64)  >> 5 | (i & 2) << 5 |     \
     (i & 32)  >> 3 | (i & 4) << 3 |     \
     (i & 16)  >> 1 | (i & 8) << 1       \
    )

static inline size_t bytes2bits(size_t nbytes){
    return nbytes * BITS_IN_BYTE;
}

/*
 * Convert bits to bytes.
 *
 * if round is false, then if nbits is not a multiple of 8, an extra byte
 * is added to the result. IOW, if round=true, return number of bytes required
 * to store nbits; otherwise truncate the excess bits.
 */
static inline size_t bits2bytes(size_t nbits, bool round){
    size_t bytes = (nbits / BITS_IN_BYTE);
    if (round){
        bytes += (nbits % BITS_IN_BYTE ? 1 : 0);
    }
    return bytes;
}

/* get the width in bits of the unsigned integral type of <num> */
#define width(num) (bytes2bits(sizeof(num)))

/*
 * Get, set, clear, or toggle the bit (1 or 0) at position pos in num.
 *
 * the rightmost bit is considered to be at position 1, increasing to the left.
 * It is assumed pos is not out of bounds of the width of the 'num' type.
 */
#define get_bit(num, pos) \
    ((num >> (pos-1)) & ON_BIT)

#define set_bit(num, pos) \
    (num | (((typeof(num))ON_BIT) << (pos-1)))

#define set_bitval(num, pos, bitval) \
    ( (num & ~( ((typeof(num))ON_BIT) << (pos-1))) | (((typeof(num))bitval) << (pos-1)) )

#define clear_bit(num, pos) \
    (num & ~(((typeof(num))ON_BIT) << (pos-1)))

#define toggle_bit(num, pos) \
    (num ^ (((typeof(num))ON_BIT) << (pos-1)))

/*
 * Get, set, clear, or toggle a number of adjacent bits.
 *
 * 'nbits' bits are operated on from pos to the right. See the comment on
 * get_bit for how bit positions are counted. A call such as get_bits(mynum, 4, 2)
 * will therefore get the bits at positions 4 and 3.
 *
 * Note get_bits shifts right at the end such that in the return value the
 * rightmost bit is the rightmost bit *that the user asked to be gotten*. So for
 * example if mynum=11001100, a call such as get_bits(mynum, 4, 2) will return
 * 00000011.
 *
 * To understand the below macros, note the following:
 *  - ~0U gives a mask of all 1s
 *  - we cast this to the same type as num to avoid subtle promotion weirdness.
 *  For example, if num is a uint64_t but our mask is made a uint32_t, then pos
 *  may correctly be specified as e.g. 55, but that's a shift beyond the witdth
 *  of a u32, resulting in undefined behavior. Note if typeof is unimplemented
 *  in the current compiler, just replace it with a cast to uint64_t instead
 *  (widest integer available).
 *  - (~0U << nbits) clears up <nbits> 0 bits on the far right, with all the other
 *  bits being 1. Negating this again therefore gives us <nbits> 1 bits on the
 *  far right with all the other bits being 0. This is our mask that we can
 *  shift to the left to the required position.
 *  - using the mask obtained at the previous step, we can shift it to the
 *  required position to the left. We've already shifted NBITS times, so we only
 *  have pos-nbits times left to shift.
 *
 *  Preconditions on the inputs
 *  ----------------------------
 *  As implied above, nbits must be <= pos, otherwise the request is nonsensical
 *  and the behavior is undefined. Additionally:
 *   - pos *must* be <= the width of the type of 'num'.
 *   - nbits *must* be > 0.
 */
#define get_bits(num, pos, nbits) \
    ( ( num & ((~ (~((typeof(num))0) << nbits) ) << (pos-nbits))) >> (pos - nbits) )

#define set_bits(num, pos, nbits) \
    ( num | ((~(~((typeof(num))0) << nbits)) << (pos-nbits)))

#define clear_bits(num, pos, nbits) \
    ( num & ~((~(~((typeof(num))0) << nbits)) << (pos-nbits)))

#define toggle_bits(num, pos, nbits) \
    ( num ^ ((~(~((typeof(num))0) << nbits)) << (pos-nbits)))

/*
 * This imagines the unsigned integral type <num> to be a bit deque.
 *
 * - rpush: shift all bits left by one, and finally shift in (push) bit at the
 *         low-order end.
 * - rpop:  shift all bits right by one, and get the bit that fell off the
 *         low-order end.
 *
 * bit *must* 1 or 0; num *must* be a variable of an unsigned integral type.
 * <lpush,lpop> to the same as <rpush, rpop> but the push is on the left
 * (high-order end) and the pop is on the right (low-order end).
 *
 * Note: the pop operation relies on the annulment and identity laws of boolean
 * algebra:   a(b+1)=a(1)=a
 * and on the fact that C expressions evaluate to a boolean value.
 * This allows the macro to perform the assignment and shfit of <num> (and be
 * callable in an if() conditional expression) and also 'return' the shifted-off
 * low-order bit.
 */
#define rpush_bit(num, bit)  ( (num << 1) | bit )
#define lpush_bit(num, bit)  ( (num >> 1) | (bit << (width(num)-1)) )
#define rpop_bit(num)   ( (num&ON_BIT) && ((num>>=1) || ON_BIT) )
#define lpop_bit(num)   ( (num&(ON_BIT << (width(num)-1))) && ((num<<=1) || ON_BIT) )

/*
 * True if x = 2^n for some n.
 *
 * see 2's complement */
static inline bool ispow2(uint64_t x){
    if ((x & (x-1)) == 0) return true;
    return false;
}

/*
 * True if x % 2 == 0 */
static inline bool ismult2(uint64_t x){
    return (! (x & 1));
}

/*
 * return the position of the most significant bit, counting from 1.
 */
static inline int posmsb(uint64_t v){
    if (!v) return 0;

    int pos = 0;
    while ((v>>=1) && ++pos);
    return pos+1;
}

/*
 * return an integral value (if you want float, see `man 2 log2`) which is the
 * position of the most significant bit in num, counting from 1. This is
 * equivalent to the truncated value of log2(num).
 */
static inline int lg(uint64_t num){
    return posmsb(num);
}

/*
 * Check if width (in bits) is wide enough to accomodate val.
 * For val to fit in width, width must be >= the position (counting from 1)
 * of the most significant bit in val.
 */
static inline bool wide_enough(int width, uint64_t val){
    return (width >= posmsb(val));
}

/*
 * generate special functions for performing '%'; when the modulus is a power
 * of 2, this can be implemented via a bitwise AND.
 *
 * NOTE:
 *  - type must be wide enough to fit pow_of_2. I.e.
 *  IOW ensure: log_2(pow_of_2) <= sizeof(type)*8.
 */
#define define_modulo_pow2(type, postfix, pow_of_2) \
    type mod##postfix(type val){ \
        return val & pow_of_2; \
    }

/*
 * Return a dynamically allocated string that contains the bits in val, left to
 * right in decreasing order of significance.
 *
 * --> val
 * the value to get the bits of.
 *
 * --> width
 * the number of bits (from least significant to most significant) to show; if
 * this is less than the width of val, the higher-order bits that do not fit are
 * left out. If this is more than the width of val, high order 0 bits are filled
 * in to pad out the output.
 *
 * <-- return
 * a dynamically allocated string that the user must free().
 */
const char *bitstr(uint64_t val, size_t width);

/*
 * Return true if s contains only '1's and '0's.
 *
 * - If sep != NULL, then it specifies a separator substring to be ignored when
 *   considering the sequence of 1s and 0s.
 * - s must not be NULL.
 * - if len != NULL, the number of 0s and 1s in the string, after discounting
 *   any occurences of separator SEP, is stored in it.
 */
bool is_valid_bitstring(const char *s, const char *sep, size_t *len);

/*
 * For each byte in src, write it to dst formatted as follows:
 *  [prefix][2 digit hex][separator]
 *
 * The separator is only printed between elements. Prefix and separator can be
 * NULL (default is empty strings if so). dst must have enough space to
 * accomodate the format of every byte in src + a NUL terminator. If this is not
 * so, -1 is returned to indicate the error.
 */
int hexstr(
        char dst[],   size_t dstlen,
        uint8_t src[],size_t srclen,
        const char *const delim,
        const char *const prefix);

/*
 * Produce a hex dump of the bytes starting at <start>.
 *
 * --> start
 * First byte (inclusive) to start dumping from.
 *
 * --> len
 * The length in bytes of the memory available to dump.
 *
 * --> width
 * How many bytes to show per line in the output
 *
 * --> print_offsets
 * Whether to print a hex number at the start of each line indicating the offset
 * inside the dump of the first byte on that line. For example '0x000040 |'.
 *
 * NOTE:
 * The Hexdump starts at an address and works its way up. On a little-endian
 * machine the bytes dumped for an e.g. uint32_t are from least to most
 * significant while on a big-endian machine they are the reverse.
 */
void dump_hex(
    const uint8_t *start,
    uint32_t len,
    uint16_t width,
    bool print_offsets);


/*
 * Copy the bytes of num into buff such that they are stored in little or
 * big-endian order, respectively.
 *
 * --> num
 * An *unsigned* integral type.
 *
 * --> buff
 * An already initialized buffer of length >= sizeof(num).
 *
 * When packed in little endian order, byte significance increases with
 * increasing memory addresses (increasing array indices). When packed in
 * big-endian order, byte significance *decreases* with increasing memory
 * addresses (increasing array indices). Such that in a big-endian-packed array
 * arr, arr[0] stores the most significant byte while in a little-endian-packed
 * array, arr[0] stores the least significant byte.
 */
#define pack_buff_le(num, buff)                                         \
    do { \
        for (unsigned int pos_ = 0; pos_ < sizeof(num); ++pos_)         \
          buff[pos_] = ( (num >> bytes2bits(pos_)) & FULL_BYTE );      \
    } while (0)

#define pack_buff_be(num, buff)                                         \
    do { \
        uint8_t *p_ = buff+sizeof(num);                                  \
        for (int pos_ = 0; pos_ < sizeof(num); ++pos_)                  \
          *(--p_) = ( (num >> bytes2bits(pos_)) & FULL_BYTE );       \
    } while (0)

/*
 * Read sizeof(typeof(num)) bytes from buff and load them into num.
 * Buf is assumed to be storing its bytes in little-endian or big-endian order
 * respectively. */
#define load_uint_be(buff, type, num) \
    do { \
        num = 0; \
        for (size_t i = 0; i < sizeof(num); ++i){ \
            num |= ( ((type)buff[i]) << (bytes2bits((sizeof(num)-1-i))) ); \
        } \
    } while(0)

#define load_uint_le(buff, type, num) \
    do { \
        num = 0; \
        for (size_t i = 0; i < sizeof(num); ++i){ \
            num |= ( ((type)buff[i]) << (bytes2bits(i)) ); \
        } \
    } while(0)

#define load_u16be(buff, num) load_uint_be(buff, uint16_t, num)
#define load_u32be(buff, num) load_uint_be(buff, uint32_t, num)
#define load_u64be(buff, num) load_uint_be(buff, uint64_t, num)
#define load_u16le(buff, num) load_uint_le(buff, uint16_t, num)
#define load_u32le(buff, num) load_uint_le(buff, uint32_t, num)
#define load_u64le(buff, num) load_uint_le(buff, uint64_t, num)


#ifdef __cplusplus
} /* extern "C" */
#endif


#endif
