#pragma once

#include <tarp/bits.hxx>
#include <tarp/math.hxx>

#include <array>
#include <cstdint>
#include <cstring>
#include <string>
#include <type_traits>

namespace tarp {
namespace hash {
namespace checksum {

// Each algorithm can be described in two stages: preprocessing and hash
// computation. Preprocessing involves padding a message, parsing the padded
// message into m-bit blocks, and setting initialization values to be used in
// the hash computation. The hash computation generates a message schedule from
// the padded message and uses that schedule, along with functions, constants,
// and word operations to iteratively generate a series of hash values. The
// final hash value generated by the hash computation is used to determine the
// message digest.

// Secure Hash Algorithm 2 (SHA-2) processing context.
struct sha256_ctx {
    using word_t = std::uint32_t;
    static inline constexpr std::size_t WORD_SIZE = sizeof(word_t);

    static inline constexpr std::size_t DIGEST_SIZE_BITS = 256;
    static inline constexpr std::size_t DIGEST_SIZE_BYTES =
      DIGEST_SIZE_BITS >> 3;
    static inline constexpr std::size_t BLOCK_SIZE_BITS = DIGEST_SIZE_BITS << 1;
    static inline constexpr std::size_t BLOCK_SIZE_BYTES = BLOCK_SIZE_BITS >> 3;
    static inline constexpr std::size_t BLOCK_SIZE_WORDS =
      BLOCK_SIZE_BYTES / WORD_SIZE;

    // Delay padding until the very last block of the message,
    // thereby enabling online processing.
    // NOTE we need twice the block size for padding
    // (see pad() below).
    static inline constexpr std::size_t BUFFSZ = BLOCK_SIZE_BYTES * 2;
    std::array<std::uint8_t, BUFFSZ> buff;

    // how many bytes in block have actually been provided;
    // used to calculate the required padding.
    std::size_t offset = 0;

    // Input message length in bytes
    std::size_t msglen = 0;

    // the hash/digest, initialized as required by the spec.
    std::array<word_t, 8> hash {0x6a09e667,
                                0xbb67ae85,
                                0x3c6ef372,
                                0xa54ff53a,
                                0x510e527f,
                                0x9b05688c,
                                0x1f83d9ab,
                                0x5be0cd19};
};

namespace sha {
void process(sha256_ctx &ctx,
             const std::uint8_t *data,
             std::size_t len,
             bool last_chunk);

void reset(sha256_ctx &ctx);

std::string get_hashstring(sha256_ctx &ctx);

std::array<std::uint8_t, sha256_ctx::DIGEST_SIZE_BYTES>
get_hashbytes(sha256_ctx &ctx);

namespace detail {
// Majority function: return the bit at each position
// that appears most often.
template<typename T>
constexpr T majority(T x, T y, T z) {
    static_assert(std::is_unsigned_v<T>);
    return (x & y) ^ (x & z) ^ (y & z);
}

// Choice function. For each bit position,
// use the bit in y if the bit in x is 1,
// else use the bit in z.
template<typename T>
constexpr T choose(T x, T y, T z) {
    return (x & y) ^ ((~x) & z);
}

// FIBS PUB 180-4, p11:
// > These words represent the first thirty-two bits of the
// > fractional parts of the cube roots of the first sixty-four
// > prime numbers.
extern std::array<sha256_ctx::word_t, 64> sha256_constants;

void process_block(sha256_ctx &ctx, const std::uint8_t *data);

// Pad the current and last chunk.
void process_last(sha256_ctx &ctx);

}  // namespace detail
}  // namespace sha

std::string sha256sum(const std::uint8_t *data, std::size_t len);

std::array<std::uint8_t, sha256_ctx::DIGEST_SIZE_BYTES>
sha256_hmac_bytes(const std::uint8_t *msg,
                  std::size_t msglen,
                  const std::uint8_t *key,
                  std::size_t keylen);

std::string
sha256_hmac_hashstring(const std::uint8_t *msg,
                  std::size_t msglen,
                  const std::uint8_t *key,
                  std::size_t keylen);




}  // namespace checksum
}  // namespace hash
}  // namespace tarp
